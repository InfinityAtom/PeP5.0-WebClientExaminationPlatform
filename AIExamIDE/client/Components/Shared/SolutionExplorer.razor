@implements IDisposable
@using System.IO
@using Microsoft.AspNetCore.Components.Web
@using MudBlazor
@using AIExamIDE.Models
@using AIExamIDE.Components.Dialogs
@inject ExamState ExamState
@inject IJSRuntime JSRuntime
@inject IDialogService DialogService

<MudPaper Style="height: 100%; background-color: #fafafa;" Square="true" Elevation="0">
    <!-- Header with Actions -->
    <MudPaper Class="pa-3" Elevation="0" Square="true" Style="border-bottom: 1px solid #e0e0e0;">
        <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Class="mb-2">
            <MudText Typo="Typo.h6" Class="font-weight-bold">Solution Explorer</MudText>
            <MudStack Row Spacing="1">
                <MudTooltip Text="New Folder">
                    <MudIconButton Icon="@Icons.Material.Filled.CreateNewFolder"
                                   Size="Size.Small"
                                   OnClick="CreateFolderQuick" />
                </MudTooltip>
                <MudTooltip Text="New File">
                    <MudIconButton Icon="@Icons.Material.Filled.NoteAdd"
                                   Size="Size.Small"
                                   OnClick="OpenAddFileDialog" />
                </MudTooltip>
                <MudTooltip Text="Refresh">
                    <MudIconButton Icon="@Icons.Material.Filled.Refresh"
                                   Size="Size.Small"
                                   OnClick="RefreshFiles" />
                </MudTooltip>
            </MudStack>
        </MudStack>

        <!-- Search Box -->
        <MudTextField @bind-Value="searchFilter"
                      Placeholder="Search files..."
                      Variant="Variant.Outlined"
                      Dense="true"
                      Adornment="Adornment.Start"
                      AdornmentIcon="@Icons.Material.Filled.Search"
                      Immediate="true" />
    </MudPaper>

    <!-- File List -->
    <MudScrollArea Style="height: calc(100% - 140px);">
        <MudContainer Class="pa-2">
            @if (ExamState.Files.Any())
            {
                <MudList T="string" Dense="true" Clickable="true">
                    @foreach (var file in GetFilteredRootFiles())
                    {
                        @if (file.IsDirectory)
                        {
                            <!-- Directory -->
                            <MudListItem T="string"
                                         OnClick="() => ToggleDirectory(file.Path)"
                                         Icon="@(IsExpanded(file.Path) ? Icons.Material.Filled.FolderOpen : Icons.Material.Filled.Folder)"
                                         IconColor="Color.Primary">
                                <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Style="width: 100%;">
                                    <MudStack Row AlignItems="AlignItems.Center">
                                        <MudIcon Icon="@(IsExpanded(file.Path) ? Icons.Material.Filled.ExpandMore : Icons.Material.Filled.ChevronRight)"
                                                 Size="Size.Small" Class="mr-1" />
                                        <MudText Class="font-weight-medium">@file.Name</MudText>
                                    </MudStack>
                                    <MudStack Row Spacing="1" @onclick:stopPropagation="true">
                                        <MudTooltip Text="Rename">
                                            <MudIconButton Icon="@Icons.Material.Filled.Edit"
                                                           Size="Size.Small"
                                                           OnClick="() => OpenRenameFileDialog(file)" />
                                        </MudTooltip>
                                        <MudTooltip Text="Delete">
                                            <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                                           Size="Size.Small"
                                                           Color="Color.Error"
                                                           OnClick="() => OpenDeleteFileDialog(file)" />
                                        </MudTooltip>
                                    </MudStack>
                                </MudStack>
                            </MudListItem>

                            <!-- Directory Children -->
                            @if (IsExpanded(file.Path))
                            {
                                @foreach (var child in file.Children.OrderBy(f => f.IsDirectory ? 0 : 1).ThenBy(f => f.Name))
                                {
                                    <MudListItem T="string"
                                                 OnClick="() => ExamState.OpenFile(child)"
                                                 Icon="@GetFileIcon(child)"
                                                 Class="ml-6">
                                        <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Style="width: 100%;">
                                            <MudText>@child.Name</MudText>
                                            <MudStack Row Spacing="1" @onclick:stopPropagation="true">
                                                <MudTooltip Text="Rename">
                                                    <MudIconButton Icon="@Icons.Material.Filled.Edit"
                                                                   Size="Size.Small"
                                                                   OnClick="() => OpenRenameFileDialog(child)" />
                                                </MudTooltip>
                                                @if (!child.IsDirectory)
                                                {
                                                    <MudTooltip Text="Duplicate">
                                                        <MudIconButton Icon="@Icons.Material.Filled.ContentCopy"
                                                                       Size="Size.Small"
                                                                       OnClick="() => DuplicateFile(child)" />
                                                    </MudTooltip>
                                                }
                                                <MudTooltip Text="Delete">
                                                    <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                                                   Size="Size.Small"
                                                                   Color="Color.Error"
                                                                   OnClick="() => OpenDeleteFileDialog(child)" />
                                                </MudTooltip>
                                            </MudStack>
                                        </MudStack>
                                    </MudListItem>
                                }
                            }
                        }
                        else
                        {
                            <!-- Root Level File -->
                            <MudListItem T="string"
                                         OnClick="() => ExamState.OpenFile(file)"
                                         Icon="@GetFileIcon(file)">
                                <MudStack Row Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Style="width: 100%;">
                                    <MudText>@file.Name</MudText>
                                    <MudStack Row Spacing="1" @onclick:stopPropagation="true">
                                        <MudTooltip Text="Rename">
                                            <MudIconButton Icon="@Icons.Material.Filled.Edit"
                                                           Size="Size.Small"
                                                           OnClick="() => OpenRenameFileDialog(file)" />
                                        </MudTooltip>
                                        <MudTooltip Text="Duplicate">
                                            <MudIconButton Icon="@Icons.Material.Filled.ContentCopy"
                                                           Size="Size.Small"
                                                           OnClick="() => DuplicateFile(file)" />
                                        </MudTooltip>
                                        <MudTooltip Text="Delete">
                                            <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                                           Size="Size.Small"
                                                           Color="Color.Error"
                                                           OnClick="() => OpenDeleteFileDialog(file)" />
                                        </MudTooltip>
                                    </MudStack>
                                </MudStack>
                            </MudListItem>
                        }
                    }
                </MudList>
            }
            else
            {
                <MudStack AlignItems="AlignItems.Center" Justify="Justify.Center" Style="height: 200px;">
                    <MudIcon Icon="@Icons.Material.Filled.Folder" Size="Size.Large" Color="Color.Default" />
                    <MudText Typo="Typo.body1" Color="Color.Default">No files loaded</MudText>
                    <MudButton StartIcon="@Icons.Material.Filled.NoteAdd"
                               Variant="Variant.Filled"
                               Color="Color.Primary"
                               Size="Size.Small"
                               OnClick="OpenAddFileDialog">
                        Create First File
                    </MudButton>
                </MudStack>
            }
        </MudContainer>
    </MudScrollArea>

    <!-- Status Bar -->
    <MudPaper Class="pa-2" Elevation="0" Square="true" Style="border-top: 1px solid #e0e0e0;">
        <MudText Typo="Typo.caption">
            @ExamState.Files.Count file(s) | @ExamState.OpenFiles.Count open
        </MudText>
    </MudPaper>
</MudPaper>

@code {
    private string searchFilter = "";
    private HashSet<string> expandedDirectories = new();
    private bool _disposed = false;

    protected override void OnInitialized()
    {
        ExamState.OnChange += StateHasChanged;
        foreach (var f in ExamState.Files.Where(f => f.IsDirectory))
            expandedDirectories.Add(f.Path);
    }

    /* ======= Dialogs: Add / Rename / Delete ======= */

    private async Task OpenAddFileDialog()
    {
        var directories = GetAllDirectories();
var parameters = new DialogParameters
{
    { "Title", "Add a new file" },
    { "Directories", directories },
    { "DefaultDirectory", directories.FirstOrDefault() ?? "" }
};


        var options = new DialogOptions { MaxWidth = MaxWidth.Small, FullWidth = true, CloseOnEscapeKey = true, BackdropClick = false};
        var dialog = DialogService.Show<AddFileDialog>("Add File", parameters, options);
        var result = await dialog.Result;
        if (result.Canceled) return;

        if (result.Data is AddFileDialog.AddFileResult add)
        {
            var fullPath = string.IsNullOrWhiteSpace(add.Directory)
                ? add.FileName
                : $"{add.Directory.TrimEnd('/')}/{add.FileName}";

            // Creează fișierul
            CreateFileInState(fullPath, add.InitialContent ?? string.Empty);
            // Deschide fișierul
            var created = ExamState.Files.FirstOrDefault(f => f.Path == fullPath);
            if (created != null && !created.IsDirectory)
                ExamState.OpenFile(created);

            StateHasChanged();
        }
    }

    private async Task OpenRenameFileDialog(ExamFile file)
    {
        var parameters = new DialogParameters
        {
            { "OriginalPath", file.Path }
        };
        var options = new DialogOptions { MaxWidth = MaxWidth.ExtraSmall, FullWidth = true, CloseOnEscapeKey = true, BackdropClick = false};
        var dialog = DialogService.Show<RenameFileDialog>("Rename", parameters, options);
        var result = await dialog.Result;
        if (result.Canceled) return;

        if (result.Data is RenameFileDialog.RenameFileResult ren)
        {
            RenameInState(ren.OriginalPath, ren.NewPath);
            StateHasChanged();
        }
    }

    private async Task OpenDeleteFileDialog(ExamFile file)
    {
        var parameters = new DialogParameters
        {
            { "Path", file.Path }
        };
        var options = new DialogOptions { MaxWidth = MaxWidth.ExtraSmall, FullWidth = true, CloseOnEscapeKey = true, BackdropClick = false};
        var dialog = DialogService.Show<DeleteFileDialog>("Delete", parameters, options);
        var result = await dialog.Result;
        if (result.Canceled) return;

        if (result.Data is DeleteFileDialog.DeleteFileResult del && del.Confirmed)
        {
            DeleteFromState(del.Path);
            StateHasChanged();
        }
    }

    private List<string> GetAllDirectories()
{
    var set = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

    foreach (var item in ExamState.Files)
    {
        if (item.IsDirectory && !string.IsNullOrWhiteSpace(item.Path))
            set.Add(item.Path);

        var path = item.Path ?? "";
        var idx = path.LastIndexOf('/');
        if (idx > 0)
        {
            var dir = path[..idx];
            var parts = dir.Split('/', StringSplitOptions.RemoveEmptyEntries);
            var acc = "";
            foreach (var p in parts)
            {
                acc = string.IsNullOrEmpty(acc) ? p : $"{acc}/{p}";
                set.Add(acc);
            }
        }
    }

    return set.OrderBy(s => s, StringComparer.OrdinalIgnoreCase).ToList();
}


    /* ======= State helpers ======= */

    private void CreateFileInState(string path, string content)
    {
        // dacă directorul nu există ca item, îl adăugăm
        var dirPath = GetDirectoryPart(path);
        if (!string.IsNullOrEmpty(dirPath) && !ExamState.Files.Any(f => f.IsDirectory && f.Path == dirPath))
        {
            ExamState.Files.Add(new ExamFile
            {
                Name = Path.GetFileName(dirPath),
                Path = dirPath,
                IsDirectory = true,
                Children = new List<ExamFile>()
            });
        }

        var file = new ExamFile
        {
            Name = Path.GetFileName(path),
            Path = path,
            IsDirectory = false,
            Content = string.IsNullOrEmpty(content) ? GetDefaultContent(Path.GetFileName(path)) : content,
            Children = new List<ExamFile>()
        };

        ExamState.Files.Add(file);

        // leagă în arborele directorului dacă există fizic în listă
        var parent = ExamState.Files.FirstOrDefault(f => f.IsDirectory && f.Path == dirPath);
        parent?.Children.Add(file);
    }

    private void RenameInState(string oldPath, string newPath)
    {
        var item = ExamState.Files.FirstOrDefault(f => f.Path == oldPath);
        if (item == null) return;

        if (!item.IsDirectory)
        {
            item.Name = Path.GetFileName(newPath);
            item.Path = newPath;
        }
        else
        {
            var oldPrefix = oldPath.TrimEnd('/') + "/";
            var newPrefix = newPath.TrimEnd('/') + "/";

            item.Name = Path.GetFileName(newPath);
            item.Path = newPath;

            // actualizează toate fișierele din director recursiv
            foreach (var f in ExamState.Files.Where(f => f.Path.StartsWith(oldPrefix) && f.Path != oldPath))
            {
                f.Path = newPrefix + f.Path.Substring(oldPrefix.Length);
            }
            // reconstruiește Children minimale pentru folderul mutat
            item.Children = ExamState.Files
                .Where(f => f.Path.StartsWith(newPrefix) && f.Path != newPath && !f.Path.Substring(newPrefix.Length).Contains('/'))
                .ToList();
        }

        // închide filele deschise care s-au mutat și le redeschide cu noul path
        var affectedOpen = ExamState.OpenFiles.Where(of => of.Path == oldPath || of.Path.StartsWith(oldPath.TrimEnd('/') + "/")).ToList();
        foreach (var of in affectedOpen)
            ExamState.CloseFile(of);

        var reopened = ExamState.Files.Where(f => f.Path == newPath || f.Path.StartsWith(newPath.TrimEnd('/') + "/") && !f.IsDirectory);
        foreach (var f in reopened)
            ExamState.OpenFile(f);
    }

    private void DeleteFromState(string targetPath)
    {
        var target = ExamState.Files.FirstOrDefault(f => f.Path == targetPath);
        if (target == null) return;

        if (!target.IsDirectory)
        {
            ExamState.CloseFile(target);
            ExamState.Files.Remove(target);
            // scoate din Children ale părintelui dacă există
            var parent = ExamState.Files.FirstOrDefault(f => f.IsDirectory && f.Path == GetDirectoryPart(targetPath));
            parent?.Children.RemoveAll(c => c.Path == targetPath);
        }
        else
        {
            var prefix = targetPath.TrimEnd('/') + "/";
            var toRemove = ExamState.Files.Where(f => f.Path == targetPath || f.Path.StartsWith(prefix)).ToList();

            foreach (var f in toRemove)
                ExamState.CloseFile(f);

            // șterge din children ale părintelui
            var parent = ExamState.Files.FirstOrDefault(f => f.IsDirectory && f.Path == GetDirectoryPart(targetPath));
            parent?.Children.RemoveAll(c => c.Path == targetPath);

            foreach (var f in toRemove)
                ExamState.Files.Remove(f);
        }
    }

    private static string GetDirectoryPart(string path)
    {
        var idx = path.LastIndexOf('/');
        return idx <= 0 ? "" : path.Substring(0, idx);
    }

private string GetDefaultContent(string filePath)
{
    if (filePath.EndsWith(".java", StringComparison.OrdinalIgnoreCase))
    {
        var className = Path.GetFileNameWithoutExtension(filePath);
        var dir = Path.GetDirectoryName(filePath)?.Replace("\\", "/") ?? string.Empty;

        string packageLine = "";
        if (!string.IsNullOrWhiteSpace(dir))
        {
            var parts = dir.Split('/', StringSplitOptions.RemoveEmptyEntries);
            // construiește pachetul din segmentele după "src"
            var pkg = string.Join(".", parts.SkipWhile(p => p.Equals("src", StringComparison.OrdinalIgnoreCase)))
                             .ToLowerInvariant();
            if (!string.IsNullOrWhiteSpace(pkg))
                packageLine = $"package {pkg};\n\n";
        }

        return $@"{packageLine}public class {className} {{

    public static void main(String[] args) {{
        System.out.println(""Hello from {className}!"");
    }}
}}";
    }

    if (filePath.EndsWith(".csv", StringComparison.OrdinalIgnoreCase))
        return "Column1,Column2,Column3\nValue1,Value2,Value3";

    return "";
}


    /* ======= UI helpers ======= */

    private bool IsExpanded(string directoryPath) => expandedDirectories.Contains(directoryPath);

    private void ToggleDirectory(string directoryPath)
    {
        if (expandedDirectories.Contains(directoryPath))
            expandedDirectories.Remove(directoryPath);
        else
            expandedDirectories.Add(directoryPath);

        StateHasChanged();
    }

    private List<ExamFile> GetFilteredRootFiles()
    {
        var root = GetRootFiles();
        if (string.IsNullOrWhiteSpace(searchFilter)) return root;

        return root.Where(f =>
            f.Name.Contains(searchFilter, StringComparison.OrdinalIgnoreCase) ||
            (f.IsDirectory && f.Children.Any(c => c.Name.Contains(searchFilter, StringComparison.OrdinalIgnoreCase)))
        ).ToList();
    }

    private List<ExamFile> GetRootFiles()
{
    // colecție de noduri de directoare la rădăcină
    var dirNodes = new Dictionary<string, ExamFile>(StringComparer.OrdinalIgnoreCase);
    // fișiere la rădăcină
    var rootFiles = new List<ExamFile>();

    // 1) preînregistrează directoarele top-level existente ca noduri
    foreach (var item in ExamState.Files)
    {
        var parts = item.Path.Split('/', StringSplitOptions.RemoveEmptyEntries);

        if (parts.Length == 1 && item.IsDirectory)
        {
            if (!dirNodes.ContainsKey(item.Path))
            {
                // folosește nodul existent ca bază, dar cu Children resetat pentru afișare
                dirNodes[item.Path] = new ExamFile
                {
                    Name = item.Name,
                    Path = item.Path,
                    IsDirectory = true,
                    Children = new List<ExamFile>()
                };
            }
        }
    }

    // 2) parcurge toate itemele și le plasează corect
    foreach (var item in ExamState.Files)
    {
        var parts = item.Path.Split('/', StringSplitOptions.RemoveEmptyEntries);

        // fișier la rădăcină
        if (parts.Length == 1 && !item.IsDirectory)
        {
            rootFiles.Add(item);
            continue;
        }

        // orice subelement într-un folder top-level
        if (parts.Length > 1)
        {
            var top = parts[0];

            // dacă nu există un folder top-level deja, creează un nod sintetic O SINGURĂ DATĂ
            if (!dirNodes.TryGetValue(top, out var topNode))
            {
                topNode = new ExamFile
                {
                    Name = top,
                    Path = top,
                    IsDirectory = true,
                    Children = new List<ExamFile>()
                };
                dirNodes[top] = topNode;
            }

            // adaugă doar copiii direcți ai folderului top-level
            // exemplu: pentru "src/Main.java" adaugă "Main.java"
            // pentru "src/sub/Deep.java" nu-l adăugăm aici, va apărea când extinzi ulterior structura
            if (parts.Length == 2)
            {
                topNode.Children.Add(item);
            }
        }
    }

    // 3) compune lista finală: directoarele (unice) + fișierele root
    var result = new List<ExamFile>();
    result.AddRange(dirNodes.Values.OrderBy(d => d.Name, StringComparer.OrdinalIgnoreCase));
    result.AddRange(rootFiles.OrderBy(f => f.Name, StringComparer.OrdinalIgnoreCase));
    return result;
}

    private List<ExamFile> GetDirectories()
        => ExamState.Files.Where(f => f.IsDirectory).ToList();

    private string GetFileIcon(ExamFile file)
    {
        if (file.IsDirectory) return Icons.Material.Filled.Folder;
        if (file.Name.EndsWith(".java", StringComparison.OrdinalIgnoreCase)) return Icons.Custom.FileFormats.FileCode;
        if (file.Name.EndsWith(".csv", StringComparison.OrdinalIgnoreCase)) return Icons.Material.Filled.TableChart;
        if (file.Name.EndsWith(".txt", StringComparison.OrdinalIgnoreCase)) return Icons.Material.Filled.TextSnippet;
        return Icons.Material.Filled.Description;
    }

    private void DuplicateFile(ExamFile file)
    {
        if (file.IsDirectory) return;

        var baseName = Path.GetFileNameWithoutExtension(file.Name);
        var ext = Path.GetExtension(file.Name);
        var copyName = $"{baseName}_copy{ext}";
        var parts = file.Path.Split('/');
        parts[^1] = copyName;
        var copyPath = string.Join("/", parts);

        // dacă există deja, incrementează sufixul
        int i = 2;
        while (ExamState.Files.Any(f => f.Path == copyPath))
        {
            copyName = $"{baseName}_copy{i}{ext}";
            parts[^1] = copyName;
            copyPath = string.Join("/", parts);
            i++;
        }

        var duplicate = new ExamFile
        {
            Name = copyName,
            Path = copyPath,
            Content = file.Content,
            IsDirectory = false,
            Children = new List<ExamFile>()
        };

        ExamState.Files.Add(duplicate);

        var parent = ExamState.Files.FirstOrDefault(f => f.IsDirectory && f.Path == GetDirectoryPart(copyPath));
        parent?.Children.Add(duplicate);

        StateHasChanged();
    }

    private void RefreshFiles() => StateHasChanged();

    /* ======= Quick create folder (no modal) ======= */
    private void CreateFolderQuick()
    {
        var baseName = "NewFolder";
        var name = baseName;
        var path = name;

        int i = 2;
        while (ExamState.Files.Any(f => f.Path == path))
        {
            name = $"{baseName}{i}";
            path = name;
            i++;
        }

        var folder = new ExamFile
        {
            Name = name,
            Path = path,
            IsDirectory = true,
            Children = new List<ExamFile>()
        };
        ExamState.Files.Add(folder);
        expandedDirectories.Add(folder.Path);
        StateHasChanged();
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            _disposed = true;
            if (ExamState != null)
                ExamState.OnChange -= StateHasChanged;
        }
    }
}
